#include "high.ceu"

native/pre do
GstElement *src;
GstElement *sink;

end

native do 
void
cb_pad_added (GstElement *dec, GstPad *pad, gpointer _)
{
  GstCaps *caps;
  GstStructure *str;
  const gchar *name;
  GstPadTemplate *templ;
  GstElementClass *klass;

  /* check media type */
  caps = gst_pad_query_caps (pad, NULL);
  str = gst_caps_get_structure (caps, 0);
  name = gst_structure_get_name (str);

  klass = GST_ELEMENT_GET_CLASS (sink);

  if (g_str_has_prefix (name, "audio")) 
    templ = gst_element_class_get_pad_template (klass, "audio_sink");
  else if (g_str_has_prefix (name, "video"))
    templ = gst_element_class_get_pad_template (klass, "video_sink");
  else if (g_str_has_prefix (name, "text")) 
    templ = gst_element_class_get_pad_template (klass, "text_sink");
  else 
    templ = NULL;

  if (templ) 
  {
    GstPad *sinkpad;

    sinkpad = gst_element_request_pad (sink, templ, NULL, NULL);

    if (!gst_pad_is_linked (sinkpad))
      gst_pad_link (pad, sinkpad);

    gst_object_unref (sinkpad);
  }
}
end

par/or do 
  var int &&argc;
  var char && &&argv;
  (argc, argv) = await OS_START;
  
  if *argc < 2 then
    _printf ("Usage: %s <uri>\n", _ELEM_N (argv, 0));
    escape 0;
  end

  _gst_init (argc, &&argv); 

  finalize
    _pipeline = _gst_pipeline_new ("pipeline");
  with
    _gst_object_unref (_pipeline);
  end

  finalize
    _src = _gst_element_factory_make ("uridecodebin", "decoder");
  with
  end

  finalize
    _sink = _gst_element_factory_make ("playsink", "sink");
  with
  end

  _assert (_pipeline);
  _assert (_src);
  _assert (_sink);

  finalize
    _bus = _gst_pipeline_get_bus (_GST_PIPELINE(_pipeline));
  with
    _gst_object_unref(_bus);
  end

  _gst_bin_add_many (_GST_BIN (_pipeline), _src, _sink, null); 
  _g_signal_connect (_G_OBJECT (_src), "pad-added", _G_CALLBACK (_cb_pad_added), null);
  _g_object_set (_G_OBJECT(_src), "uri", _ELEM_N (argv,1), null);

  _gst_element_set_state (_pipeline, _GST_STATE_PLAYING);
  finalize with
    _gst_element_set_state (_pipeline, _GST_STATE_NULL);
  end
  await FOREVER;
with 
  watching GST_MESSAGE_ERROR do
    watching GST_MESSAGE_EOS do
      // programa
      every 1s do
        _printf("ok\n");
      end
    end
  end
end

escape 0;
